[4mdup[24m(2)        System Calls Manual       [4mdup[24m(2)

[1mNAME[0m
       dup,  dup2, dup3 - duplicate a file de‚Äê
       scriptor

[1mLIBRARY[0m
       Standard C library ([4mlibc[24m, [4m-lc[24m)

[1mSYNOPSIS[0m
       [1m#include <unistd.h>[0m

       [1mint dup(int [4m[22moldfd[24m[1m);[0m
       [1mint dup2(int [4m[22moldfd[24m[1m, int [4m[22mnewfd[24m[1m);[0m

       [1m#define _GNU_SOURCE             [22m/* See feature_test_macros(7) */
       [1m#include <fcntl.h>              [22m/* Definition of [1mO_* [22mconstants */
       [1m#include <unistd.h>[0m

       [1mint dup3(int [4m[22moldfd[24m[1m, int [4m[22mnewfd[24m[1m, int [4m[22mflags[24m[1m);[0m

[1mDESCRIPTION[0m
       The [1mdup[22m() system call allocates  a  new
       file descriptor that refers to the same
       open file description as the descriptor
       [4moldfd[24m.   (For  an  explanation  of open
       file descriptions, see  [1mopen[22m(2).)   The
       new  file  descriptor number is guaran‚Äê
       teed to be the lowest-numbered file de‚Äê
       scriptor that was unused in the calling
       process.

       After a successful return, the old  and
       new file descriptors may be used inter‚Äê
       changeably.   Since  the  two  file de‚Äê
       scriptors refer to the same  open  file
       description, they share file offset and
       file  status flags; for example, if the
       file  offset  is  modified   by   using
       [1mlseek[22m(2)  on  one  of the file descrip‚Äê
       tors, the offset is  also  changed  for
       the other file descriptor.

       The  two  file descriptors do not share
       file descriptor  flags  (the  close-on-
       exec  flag).   The  close-on-exec  flag
       ([1mFD_CLOEXEC[22m; see [1mfcntl[22m(2)) for the  du‚Äê
       plicate descriptor is off.

   [1mdup2()[0m
       The  [1mdup2[22m()  system  call  performs the
       same task as [1mdup[22m(), but instead of  us‚Äê
       ing the lowest-numbered unused file de‚Äê
       scriptor,  it  uses the file descriptor
       number specified in  [4mnewfd[24m.   In  other
       words, the file descriptor [4mnewfd[24m is ad‚Äê
       justed  so  that  it  now refers to the
       same open file description as [4moldfd[24m.

       If the file descriptor [4mnewfd[24m was previ‚Äê
       ously open, it is closed  before  being
       reused; the close is performed silently
       (i.e.,  any errors during the close are
       not reported by [1mdup2[22m()).

       The steps of closing  and  reusing  the
       file  descriptor  [4mnewfd[24m  are  performed
       [4matomically[24m.  This is important, because
       trying to  implement  equivalent  func‚Äê
       tionality   using  [1mclose[22m(2)  and  [1mdup[22m()
       would be subject  to  race  conditions,
       whereby  [4mnewfd[24m  might be reused between
       the two steps.  Such reuse could happen
       because the main program is interrupted
       by a signal handler  that  allocates  a
       file  descriptor, or because a parallel
       thread allocates a file descriptor.

       Note the following points:

       ‚Ä¢  If [4moldfd[24m is not  a  valid  file  de‚Äê
          scriptor,  then  the call fails, and
          [4mnewfd[24m is not closed.

       ‚Ä¢  If [4moldfd[24m is a valid file descriptor,
          and [4mnewfd[24m  has  the  same  value  as
          [4moldfd[24m, then [1mdup2[22m() does nothing, and
          returns [4mnewfd[24m.

   [1mdup3()[0m
       [1mdup3[22m()  is  the  same as [1mdup2[22m(), except
       that:

       ‚Ä¢  The caller can force  the  close-on-
          exec flag to be set for the new file
          descriptor  by  specifying [1mO_CLOEXEC[0m
          in [4mflags[24m.  See  the  description  of
          the same flag in [1mopen[22m(2) for reasons
          why this may be useful.

       ‚Ä¢  If  [4moldfd[24m  equals [4mnewfd[24m, then [1mdup3[22m()
          fails with the error [1mEINVAL[22m.

[1mRETURN VALUE[0m
       On success, these system  calls  return
       the  new file descriptor.  On error, -1
       is returned, and [4merrno[24m is set to  indi‚Äê
       cate the error.

[1mERRORS[0m
       [1mEBADF  [4m[22moldfd[24m  isn't  an  open  file de‚Äê
              scriptor.

       [1mEBADF  [4m[22mnewfd[24m  is  out  of  the  allowed
              range  for file descriptors (see
              the discussion of  [1mRLIMIT_NOFILE[0m
              in [1mgetrlimit[22m(2)).

       [1mEBUSY  [22m(Linux  only)  This  may  be re‚Äê
              turned by [1mdup2[22m() or [1mdup3[22m()  dur‚Äê
              ing   a   race   condition  with
              [1mopen[22m(2) and [1mdup[22m().

       [1mEINTR  [22mThe [1mdup2[22m() or  [1mdup3[22m()  call  was
              interrupted  by  a  signal;  see
              [1msignal[22m(7).

       [1mEINVAL [22m([1mdup3[22m()) [4mflags[24m  contain  an  in‚Äê
              valid value.

       [1mEINVAL [22m([1mdup3[22m())   [4moldfd[24m  was  equal  to
              [4mnewfd[24m.

       [1mEMFILE [22mThe  per-process  limit  on  the
              number  of open file descriptors
              has been reached (see  the  dis‚Äê
              cussion   of   [1mRLIMIT_NOFILE  [22min
              [1mgetrlimit[22m(2)).

[1mSTANDARDS[0m
       [1mdup[22m()
       [1mdup2[22m() POSIX.1-2008.

       [1mdup3[22m() Linux.

[1mHISTORY[0m
       [1mdup[22m()
       [1mdup2[22m() POSIX.1-2001, SVr4, 4.3BSD.

       [1mdup3[22m() Linux 2.6.27, glibc 2.9.

[1mNOTES[0m
       The error returned by [1mdup2[22m() is differ‚Äê
       ent from that  returned  by  [1mfcntl([22m...,
       [1mF_DUPFD[22m,  ...[1m)   [22mwhen  [4mnewfd[24m  is out of
       range.  On some  systems,  [1mdup2[22m()  also
       sometimes returns [1mEINVAL [22mlike [1mF_DUPFD[22m.

       If  [4mnewfd[24m  was  open,  any  errors that
       would have been  reported  at  [1mclose[22m(2)
       time  are lost.  If this is of concern,
       then‚Äîunless  the  program  is   single-
       threaded and does not allocate file de‚Äê
       scriptors  in  signal handlers‚Äîthe cor‚Äê
       rect approach is [4mnot[24m to close [4mnewfd[24m be‚Äê
       fore calling  [1mdup2[22m(),  because  of  the
       race  condition  described  above.  In‚Äê
       stead, code something like the  follow‚Äê
       ing could be used:

           /* Obtain a duplicate of 'newfd' that can subsequently
              be used to check for close() errors; an EBADF error
              means that 'newfd' was not open. */

           tmpfd = dup(newfd);
           if (tmpfd == -1 && errno != EBADF) {
               /* Handle unexpected dup() error. */
           }

           /* Atomically duplicate 'oldfd' on 'newfd'. */

           if (dup2(oldfd, newfd) == -1) {
               /* Handle dup2() error. */
           }

           /* Now check for close() errors on the file originally
              referred to by 'newfd'. */

           if (tmpfd != -1) {
               if (close(tmpfd) == -1) {
                   /* Handle errors from close. */
               }
           }

[1mSEE ALSO[0m
       [1mclose[22m(2),       [1mfcntl[22m(2),      [1mopen[22m(2),
       [1mpidfd_getfd[22m(2)

Linux man-page... 2023-10-31            [4mdup[24m(2)
